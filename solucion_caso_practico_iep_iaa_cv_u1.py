# -*- coding: utf-8 -*-
"""Solucion_caso_practico_IEP_IAA_CV_u1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jQx5tJCiGQCLfVjj_Ms3kuz6veuf5lv6

# Caso Pr√°ctico Unidad 1 ‚Äì Tratamiento de Im√°genes con Python y OpenCV

## Preguntas cr√≠ticas para el desarrollo del ejercicio

1. **¬øC√≥mo verificamos si la imagen fue cargada correctamente en OpenCV?**  
   Para evitar errores si la ruta del archivo est√° mal o el archivo no es v√°lido.

2. **¬øCu√°l es la diferencia visual y estructural entre la imagen original y su versi√≥n en escala de grises?**  
   Para entender c√≥mo cambia la representaci√≥n de la informaci√≥n visual.

3. **¬øQu√© tipo de filtro de desenfoque es m√°s adecuado para reducir el ruido sin perder detalles importantes?**  
   Para seleccionar el mejor filtro entre opciones como `GaussianBlur`, `medianBlur` o `bilateralFilter`.

4. **¬øQu√© par√°metros del algoritmo Canny afectan la sensibilidad en la detecci√≥n de bordes y c√≥mo elegirlos?**  
   Para afinar los resultados del algoritmo ajustando `threshold1` y `threshold2`.

5. **¬øC√≥mo garantizamos que las im√°genes procesadas se guarden correctamente en el entorno de Google Colab o Drive?**  
   Para verificar que la persistencia de datos funcione y no haya p√©rdidas.

6. **¬øQu√© utilidad tiene esta cadena de procesamiento (grises ‚Üí desenfoque ‚Üí bordes) antes de aplicar modelos de IA?**  
   Para reflexionar sobre el valor del preprocesamiento en sistemas de visi√≥n por computadora.

---

## Resultados esperados del caso pr√°ctico

| Etapa                            | Resultado Esperado                                                              |
|----------------------------------|----------------------------------------------------------------------------------|
| 1. Lectura y visualizaci√≥n       | Imagen cargada correctamente y visualizada en color                             |
| 2. Conversi√≥n a escala de grises | Imagen en blanco y negro con contornos bien definidos                           |
| 3. Filtro de desenfoque          | Imagen suavizada con reducci√≥n notable del ruido                                |
| 4. Detecci√≥n de bordes (Canny)   | Imagen con contornos marcados en blanco sobre fondo negro                       |
| 5. Guardado de resultados        | Tres im√°genes guardadas: escala de grises, desenfocada y bordes (`.png` o `.jpg`)|
| 6. C√≥digo comentado              | C√≥digo limpio y con comentarios que expliquen cada parte del flujo              |
| 7. Manejo de errores             | Uso de `try-except` para evitar fallos silenciosos al leer o guardar im√°genes   |
"""

# Procedemos con la instalaci√≥n de librerias
!pip install opencv-python-headless --quiet

import cv2
import numpy as np
import matplotlib.pyplot as plt
import urllib.request
import os

# Decid√≠ elegir una imagen de dominio p√∫blico
image_url = 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/PNG_transparency_demonstration_1.png/640px-PNG_transparency_demonstration_1.png'
image_path = 'original_image.png'

# Descargar la imagen si no existe
try:
    if not os.path.exists(image_path):
        urllib.request.urlretrieve(image_url, image_path)
        print("Imagen descargada correctamente.")
    else:
        print("‚ÑπImagen ya estaba descargada.")
except Exception as e:
    print(f"Error al descargar la imagen: {e}")

# üì∑ Leer la imagen con OpenCV
image = cv2.imread(image_path)

# Validaci√≥n
if image is None:
    raise ValueError("No se pudo cargar la imagen.")
else:
    print("Imagen cargada correctamente.")

# Convertir de BGR (OpenCV) a RGB para visualizaci√≥n con matplotlib
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Mostrar imagen original
plt.imshow(image_rgb)
plt.title("Imagen Original")
plt.axis('off')
plt.show()

# Convertimos a escala de grises
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Mostramos imagen en escala de grises
plt.imshow(gray_image, cmap='gray')
plt.title("Imagen en Escala de Grises")
plt.axis('off')
plt.show()

# Guardamos
cv2.imwrite("imagen_gris.png", gray_image)

# Aplicamos desenfoque gaussiano
blurred_image = cv2.GaussianBlur(gray_image, (5, 5), 0)

# Mostramos imagen desenfocada
plt.imshow(blurred_image, cmap='gray')
plt.title("Imagen Desenfocada (Gaussian Blur)")
plt.axis('off')
plt.show()

# Guardamos
cv2.imwrite("imagen_desenfocada.png", blurred_image)

# Aplicamos entonces detecci√≥n de bordes con Canny
edges = cv2.Canny(blurred_image, threshold1=50, threshold2=150)

# Mostramos bordes detectados
plt.imshow(edges, cmap='gray')
plt.title("Detecci√≥n de Bordes (Canny)")
plt.axis('off')
plt.show()

# Guardamos
cv2.imwrite("imagen_bordes.png", edges)

import os

print("Archivos guardados:")
for file in ["imagen_gris.png", "imagen_desenfocada.png", "imagen_bordes.png"]:
    print(f" {file} - {'Existe' if os.path.exists(file) else 'No encontrado'}")

"""## Conclusi√≥n del Caso Pr√°ctico: Tratamiento de Im√°genes con Python y OpenCV

En este ejercicio se abordaron de forma pr√°ctica los conceptos fundamentales del tratamiento de im√°genes en el contexto de la Visi√≥n por Computador. Se cumpli√≥ de manera satisfactoria el enunciado propuesto al completar cada una de las etapas solicitadas:

1. **Lectura y visualizaci√≥n de imagen**  
   Se utiliz√≥ una imagen en formato PNG desde una fuente p√∫blica (Wikimedia Commons) y fue le√≠da correctamente con OpenCV. Se visualiz√≥ en su forma original aplicando la conversi√≥n de espacio de color BGR a RGB para compatibilidad con Matplotlib.

2. **Conversi√≥n a escala de grises**  
   Se convirti√≥ la imagen a escala de grises, permitiendo reducir la dimensionalidad de los datos y prepararla para posteriores etapas de procesamiento.

3. **Aplicaci√≥n de filtro de desenfoque**  
   Se aplic√≥ un filtro Gaussiano para reducir el ruido presente en la imagen, lo cual es una pr√°ctica com√∫n y necesaria antes de realizar operaciones de detecci√≥n de bordes.

4. **Detecci√≥n de bordes (Canny)**  
   Se utiliz√≥ el algoritmo de detecci√≥n de bordes de Canny, un m√©todo cl√°sico y eficaz en visi√≥n por computadora. Esta t√©cnica permiti√≥ resaltar los contornos y transiciones abruptas en la imagen, facilitando la segmentaci√≥n y an√°lisis estructural.

5. **Guardado de im√°genes procesadas**  
   Cada una de las etapas gener√≥ una imagen de salida (en escala de grises, desenfocada y con bordes detectados), las cuales fueron guardadas correctamente en el entorno local del notebook.

### Valor a√±adido
Adem√°s de cumplir los requerimientos, se integr√≥ manejo de errores b√°sico, comentarios explicativos para cada bloque de c√≥digo, y visualizaci√≥n clara con `matplotlib`. Esto refuerza la comprensi√≥n de cada paso y facilita la reutilizaci√≥n del c√≥digo en otros casos.

---

### Conclusi√≥n Final:
Este caso pr√°ctico permiti√≥ aplicar herramientas reales del entorno de Computer Vision en un flujo b√°sico pero esencial. Sent√≥ las bases para tareas m√°s avanzadas como segmentaci√≥n, detecci√≥n de objetos, clasificaci√≥n de im√°genes, o implementaci√≥n de modelos con redes neuronales convolucionales (CNN).


"""