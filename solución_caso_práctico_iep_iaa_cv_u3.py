# -*- coding: utf-8 -*-
"""Solución_Caso_Práctico_IEP-IAA-CV-u3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FfVGp_Bd29n2Uv4ZhCsygRF33InZPvb4

### Instalación de bibliotecas

Para este proyecto usamos OpenCV y Scikit-Image, dos frameworks fundamentales en visión por computadora. Estas bibliotecas nos permiten realizar desde operaciones básicas como lectura de imágenes hasta tareas avanzadas como segmentación y detección de objetos.

_Referencia: Unidad 3 – Aplicaciones en Computer Vision y frameworks de desarrollo._
"""

!pip install opencv-python-headless scikit-image

"""### Operaciones Básicas con Imágenes

Este bloque refleja los pasos iniciales del procesamiento visual automático: adquirir la imagen, convertirla a escala de grises para simplificar su análisis, y almacenarla.

_Referencia: Paso 1 del flujo de visión por computadora – Adquisición y preprocesamiento._
"""

# Paso 2: Leer, mostrar, convertir y guardar una imagen

import cv2
import matplotlib.pyplot as plt

# Ruta de la imagen
ruta_imagen = '/content/drive/MyDrive/Colab Notebooks/datos_IEP_IAA_CV_u3/imagen.jpeg'

# Lectura imagen en formato BGR
imagen_bgr = cv2.imread(ruta_imagen)

# Verificamos que se haya cargado correctamente
if imagen_bgr is None:
    print("Error al cargar la imagen. Verifica la ruta.")
else:
    # Convertimos de BGR a RGB para visualizar correctamente con matplotlib
    imagen_rgb = cv2.cvtColor(imagen_bgr, cv2.COLOR_BGR2RGB)

    # Mostramos imagen original
    plt.figure(figsize=(6, 6))
    plt.imshow(imagen_rgb)
    plt.title("Imagen Original (RGB)")
    plt.axis('off')
    plt.show()

    # Convertimos a escala de grises
    imagen_gris = cv2.cvtColor(imagen_bgr, cv2.COLOR_BGR2GRAY)

    # Mostramos imagen en escala de grises
    plt.figure(figsize=(6, 6))
    plt.imshow(imagen_gris, cmap='gray')
    plt.title("Imagen en Escala de Grises")
    plt.axis('off')
    plt.show()

    # Guardamos imagen procesada en escala de grises
    ruta_guardado = '/content/drive/MyDrive/Colab Notebooks/datos_IEP_IAA_CV_u3/imagen_gris.jpeg'
    cv2.imwrite(ruta_guardado, imagen_gris)
    print(f"Imagen en escala de grises guardada en: {ruta_guardado}")

"""### Transformaciones Geométricas

Redimensionar, rotar y recortar permiten preparar las imágenes para su análisis. Estas transformaciones son clave para adaptar el contenido visual a los requisitos del modelo.

_Referencia: Paso 2 del flujo de visión por computadora – Procesamiento y normalización geométrica._

"""

import cv2
import matplotlib.pyplot as plt

# Asegurarse de que la imagen original esté cargada
imagen = cv2.imread('/content/drive/MyDrive/Colab Notebooks/datos_IEP_IAA_CV_u3/imagen.jpeg')

if imagen is None:
    print("No se pudo cargar la imagen.")
else:
    # --- Redimensionar a 200x200 píxeles ---
    redimensionada = cv2.resize(imagen, (200, 200))
    plt.figure(figsize=(4, 4))
    plt.imshow(cv2.cvtColor(redimensionada, cv2.COLOR_BGR2RGB))
    plt.title("Redimensionada (200x200)")
    plt.axis('off')
    plt.show()

    # --- Rotar la imagen 45 grados alrededor del centro ---
    (h, w) = imagen.shape[:2]
    centro = (w // 2, h // 2)
    matriz_rotacion = cv2.getRotationMatrix2D(centro, 45, 1.0)
    rotada = cv2.warpAffine(imagen, matriz_rotacion, (w, h))
    plt.figure(figsize=(5, 5))
    plt.imshow(cv2.cvtColor(rotada, cv2.COLOR_BGR2RGB))
    plt.title("Rotada 45°")
    plt.axis('off')
    plt.show()

    # --- Recorte de una región de interés (ROI) ---
    # Ajustamos estos valores según el tamaño de tu imagen
    roi = imagen[100:300, 100:300]  # Y:100–300, X:100–300
    plt.figure(figsize=(4, 4))
    plt.imshow(cv2.cvtColor(roi, cv2.COLOR_BGR2RGB))
    plt.title("Región Recortada (ROI)")
    plt.axis('off')
    plt.show()

"""### Filtros y Transformaciones

El suavizado reduce el ruido visual, mejorando la calidad de las imágenes para tareas posteriores. La detección de bordes (Canny) resalta contornos y formas, útil en diagnósticos médicos y vigilancia.

_Referencia: Aplicaciones en medicina – Detección de anomalías y estructuras visuales._

"""

import cv2
import matplotlib.pyplot as plt

# Leer nuevamente la imagen y su versión en escala de grises
img = cv2.imread('/content/drive/MyDrive/Colab Notebooks/datos_IEP_IAA_CV_u3/imagen.jpeg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# --- Suavizado con filtro Gaussiano ---
# Este filtro reduce el ruido preservando los bordes suaves
imagen_suavizada = cv2.GaussianBlur(img, (7, 7), 0)
plt.figure(figsize=(5, 5))
plt.imshow(cv2.cvtColor(imagen_suavizada, cv2.COLOR_BGR2RGB))
plt.title("Imagen Suavizada (Gaussiano)")
plt.axis('off')
plt.show()

# --- Detección de bordes con algoritmo de Canny ---
# Este método detecta los contornos mediante gradientes de intensidad
bordes = cv2.Canny(gray, 100, 200)
plt.figure(figsize=(5, 5))
plt.imshow(bordes, cmap='gray')
plt.title("Bordes Detectados (Canny)")
plt.axis('off')
plt.show()

"""### Detección de Objetos – Caras

Utilizamos clasificadores Haar para detectar rostros, una técnica ampliamente usada en seguridad, reconocimiento facial y control de accesos.

_Referencia: Aplicaciones de visión artificial en seguridad y vigilancia automatizada._

"""

# Cargamos Haar Cascade
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

# Detección de caras
faces = face_cascade.detectMultiScale(gray, 1.1, 4)

# Dibujamos rectángulos sobre las caras
for (x, y, w, h) in faces:
    cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)

plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.title("Detección de Caras")
plt.axis('off')
plt.show()

"""### Segmentación por Umbralización Global

La técnica de Otsu separa fondo y objeto automáticamente. Es muy útil en medicina para resaltar estructuras en resonancias o radiografías.

_Referencia: Segmentación en imágenes médicas – Separación de tejidos y estructuras._

"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from skimage.filters import threshold_otsu, threshold_local
from skimage.color import rgb2gray
from sklearn.cluster import KMeans

# Cargar una imagen (necesitas una imagen para procesar)
# Opción 1: Cargar desde archivo
# img = cv2.imread('tu_imagen.jpg')

# Opción 2: Crear una imagen de ejemplo para testing
img = np.random.randint(0, 255, (300, 300, 3), dtype=np.uint8)

# Convertir a escala de grises
gray = rgb2gray(img)

# Umbralización global con Otsu
thresh_val = threshold_otsu(gray)
binary_global = gray > thresh_val
plt.imshow(binary_global, cmap='gray')
plt.title("Umbralización Global (Otsu)")
plt.axis('off')
plt.show()

# Umbralización adaptativa
adaptive_thresh = threshold_local(gray, block_size=35, offset=10)
binary_adaptive = gray > adaptive_thresh
plt.imshow(binary_adaptive, cmap='gray')
plt.title("Umbralización Adaptativa")
plt.axis('off')
plt.show()

# Segmentación por K-means
Z = img.reshape((-1, 3))
Z = np.float32(Z)

criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
K = 3
_, labels, centers = cv2.kmeans(Z, K, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)

centers = np.uint8(centers)
segmented_img = centers[labels.flatten()].reshape((img.shape))

plt.imshow(cv2.cvtColor(segmented_img, cv2.COLOR_BGR2RGB))
plt.title("Segmentación K-Means (K=3)")
plt.axis('off')
plt.show()

"""Este caso práctico de la Unidad 3 nos permitió consolidar y ampliar los conocimientos adquiridos en la Unidad 2, integrando nuevas técnicas y frameworks clave para el desarrollo de soluciones en visión por computadora. Reafirmamos el proceso completo de un sistema de visión: desde la adquisición y preprocesamiento de imágenes, hasta la segmentación avanzada y la detección de objetos como rostros.

El uso de OpenCV y Scikit-Image no solo nos brindó herramientas potentes y accesibles para operar sobre imágenes digitales, sino que también evidenció el impacto real de la visión artificial en áreas como medicina y seguridad, donde la automatización y precisión son fundamentales.

Además, al aplicar métodos como la umbralización adaptativa, detección con Haar Cascades, y K-Means clustering, fuimos capaces de realizar tareas que imitan el análisis visual humano, pero con mayor rapidez y objetividad. Estas prácticas no solo fortalecen nuestras habilidades técnicas, sino que también nos preparan para enfrentar desafíos reales en contextos clínicos, industriales y sociales donde la visión por computadora está marcando la diferencia.
"""